rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
library(lme4)
library(simr)
datPath <- '/Users/au706616/Documents/Experiments/SPINALTGI/'
setwd(datPath)
df_phs <- read.csv(file.choose())
# need to recode levels for cold_probe to reduce number of levels from 4 to 2
df_phs$cold_location[df_phs$cold_probe == 'distal'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'rostral'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'proximal'] <- 'prox_caud'
df_phs$cold_location[df_phs$cold_probe == 'caudal'] <- 'prox_caud'
df_phs$cold_location <- as.factor(df_phs$cold_location)
# Summarise data per rating, per participant
# although summary not needed!
sum_pain <- aggregate(VASburning~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_warm <- aggregate(VASwarm~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_cold <- aggregate(VAScold~ID*manipulation*condition*cold_probe, median, data = df_phs)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(VAScold ~ manipulation + (1+manipulation|ID), data = df_phs)
summary(model.cold)
coef(model.cold)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(VAScold ~ manipulation + (1|ID), data = df_phs)
summary(model.cold)
coef(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model1, along="ID", n=20)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along="ID", n=20)
View(model.coldN)
# extract fixed effects from the model
tgi_effect <- fixef(model.coldN)["manipulationTGI"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["manipulationTGI"] <- -17
# then run power analysis
powerSim(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along="ID", n=10)
# extract fixed effects from the model
tgi_effect <- fixef(model.coldN)["manipulationTGI"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.coldN)
View(model.cold)
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["manipulationTGI"] <- 10
# then run power analysis
powerSim(model.coldN)
# transform variables into proportions (aka divide by 100), this makes the effect size estimates more logical
df_phs$cold <- df_phs$VAScold/100
View(df_phs)
df_phs$warm <- df_phs$VASwarm/100
df_phs$burn <- df_phs$VASburning/100
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(cold ~ manipulation + (1|ID), data = df_phs)
summary(model.cold)
coef(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along="ID", n=10)
summary(model.coldN)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along=ID, n=10)
pc <- powerCurve(model.cold)
pc
class(df_phs$ID)
df_phs$ID <- factor(df_phs$ID)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(cold ~ manipulation + (1|ID), data = df_phs)
summary(model.cold)
coef(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along='ID', n=10)
summary(model.coldN)
pc <- powerCurve(model.coldN)
pc
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along='manipulationTGI', n=10)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within ='manipulationTGI', n=10)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along ='manipulationTGI', n=10)
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
library(simr)
datPath <- '/Users/au706616/Documents/Experiments/SPINALTGI/'
setwd(datPath)
df_phs <- read.csv(file.choose())
# need to recode levels for cold_probe to reduce number of levels from 4 to 2
df_phs$cold_location[df_phs$cold_probe == 'distal'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'rostral'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'proximal'] <- 'prox_caud'
df_phs$cold_location[df_phs$cold_probe == 'caudal'] <- 'prox_caud'
df_phs$cold_location <- as.factor(df_phs$cold_location)
View(df_phs)
# Summarise data per rating, per participant
# although summary not needed!
sum_pain <- aggregate(VASburning~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_warm <- aggregate(VASwarm~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_cold <- aggregate(VAScold~ID*manipulation*condition*cold_probe, median, data = df_phs)
# transform variables into proportions (aka divide by 100), this makes the effect size estimates more logical
df_phs$cold <- df_phs$VAScold/100
df_phs$warm <- df_phs$VASwarm/100
df_phs$burn <- df_phs$VASburning/100
df_phs$ID <- factor(df_phs$ID)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(cold ~ manipulation + (1|ID), data = df_phs)
summary(model.cold)
View(df_phs)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along ='manipulationTGI', n=10)
model.cold3 <- lmer(VAScold ~ manipulation + condition + cold_location +
(1|ID),
data = df_phs)
summary(model.cold3)
model.cold3 <- lmer(cold ~ manipulation + condition + cold_location +
(1|ID),
data = df_phs)
summary(model.cold3)
rm(lits)
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
datPath <- '/Users/au706616/Documents/Code/LMEM_tutorial/'
setwd(datPath)
# load data frame
politeness <- read.csv(file.choose())
missing <- which(!complete.cases(politeness)) #find any missing values
head(politeness) #overview
View(politeness)
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
library(simr)
datPath <- '/Users/au706616/Documents/Experiments/SPINALTGI/'
setwd(datPath)
df_phs <- read.csv(file.choose())
# need to recode levels for cold_probe to reduce number of levels from 4 to 2
df_phs$cold_location[df_phs$cold_probe == 'distal'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'rostral'] <- 'dist_rostr'
df_phs$cold_location[df_phs$cold_probe == 'proximal'] <- 'prox_caud'
df_phs$cold_location[df_phs$cold_probe == 'caudal'] <- 'prox_caud'
df_phs$cold_location <- as.factor(df_phs$cold_location)
# transform variables into proportions (aka divide by 100), this makes the effect size estimates more logical
df_phs$cold <- df_phs$VAScold/100
df_phs$warm <- df_phs$VASwarm/100
df_phs$burn <- df_phs$VASburning/100
df_phs$ID <- factor(df_phs$ID)
# Summarise data per rating, per participant
sum_burn <- aggregate(burn~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_warm <- aggregate(warm~ID*manipulation*condition*cold_probe, median, data = df_phs)
sum_cold <- aggregate(cold~ID*manipulation*condition*cold_probe, median, data = df_phs)
# then compile all data again
sum_burn$VAS = 'burn'
sum_warm$VAS = 'warm'
sum_cold$VAS = 'cold'
df_sum <- rbind(sum_cold, sum_warm)
View(df_phs)
# Summarise data per rating, per participant
sum_burn <- aggregate(burn~ID*manipulation*condition*cold_location*procedure, median, data = df_phs)
sum_warm <- aggregate(warm~ID*manipulation*condition*cold_location*procedure, median, data = df_phs)
sum_cold <- aggregate(cold~ID*manipulation*condition*cold_location*procedure, median, data = df_phs)
# then compile all data again
sum_burn$VAS = 'burn'
sum_warm$VAS = 'warm'
sum_cold$VAS = 'cold'
df_sum <- rbind(sum_cold, sum_warm)
View(sum_burn)
View(sum_cold)
View(sum_warm)
names(sum_burn)[6] <- 'rating'
names(sum_warm)[6] <- 'rating'
names(sum_cold)[6] <- 'rating'
df_sum <- rbind(sum_cold, sum_warm)
df_sum <- rbind(df_sum, sum_burn)
View(df_sum)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(cold ~ manipulation + (1|ID), data = df_sum)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(VAS ~ manipulation + (1|ID), data = df_sum[df_sum$VAS=='cold'])
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(VAS ~ manipulation + (1|ID), data = df_sum[df_sum$VAS=='cold' ,])
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + (1|ID), data = df_sum[df_sum$VAS=='cold' ,])
summary(model.cold)
summary(model.cold)
coef(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along ='manipulationTGI', n=20)
# extract fixed effects from the model
tgi_effect <- fixef(model.cold)["manipulationTGI"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- .20
# then run power analysis
powerSim(model.cold)
help("isSingular")
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along ='ID', n=20)
summary(model.coldN)
nrow(getData(model.coldN))
nrow(getData(model.cold))
# extract fixed effects from the model
tgi_effect <- fixef(model.coldN)["manipulationTGI"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["manipulationTGI"] <- .20
# then run power analysis
powerSim(model.coldN)
pc.cold <- powerCurve(model.coldN)
print(pc.cold)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + condition + (1|ID),
data = df_sum[df_sum$VAS=='cold' ,])
summary(model.cold)
# View the coefficients for each person (should vary, due to random slope model)
```{r}
coef(model.cold)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.cold)["conditionwithin"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.coldN)
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, along ='ID', n=20)
summary(model.coldN)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=20)
xtabs(~ manipulation + condition, data=getData(cold.model))
xtabs(~ manipulation + condition, data=getData(model.cold))
xtabs(~ manipulation + condition, data=getData(model.coldN))
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=30)
summary(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition, data=getData(model.coldN))
print(dat_model)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["conditionwithin"]
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition, data=getData(model.coldN))
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=30)
summary(model.coldN)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + condition + (1|ID),
data = df_sum[df_sum$VAS=='cold' ,])
summary(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=30)
summary(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition, data=getData(model.coldN))
print(dat_model)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["conditionwithin"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=50)
summary(model.coldN)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + condition + (1|ID),
data = df_sum[df_sum$VAS=='cold' ,])
summary(model.cold)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition', n=50)
summary(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition, data=getData(model.coldN))
print(dat_model)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["conditionwithin"]
f
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.cold)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(cold ~ manipulation + condition + (1|ID),
data = df_phs)
summary(model.cold)
coef(model.cold)
xtabs(~ manipulation + condition, data=getData(model.coldN))
xtabs(~ manipulation + condition, data=getData(model.cold))
data = df_sum[df_sum$VAS == 'cold ,])
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + condition + (1|ID),
data = df_sum[df_sum$VAS == 'cold' ,])
summary(model.cold)
# first try this on just one, simple model. The effect of manipulation on cold rating, with ID as a random effect
model.cold <- lmer(rating ~ manipulation + condition + cold_location +
(1|ID) + (1|procedure),
data = df_sum[df_sum$VAS == 'cold' ,])
summary(model.cold)
xtabs(~ manipulation + condition + cold_location, data=getData(model.cold))
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition?cold_location', n=100)
# add more participants to the model, for simulation
model.coldN <- extend(model.cold, within = 'manipulation+condition+cold_location', n=100)
summary(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition, data=getData(model.coldN))
print(dat_model)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition + cold_location, data=getData(model.coldN))
print(dat_model)
summary(model.coldN)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["cold_locationprox_caud"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.cold)["manipulationTGI"] <- tgi_effect
# then run power analysis
powerSim(model.cold)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["cold_locationprox_caud"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["cold_locationprox_caud"] <- tgi_effect
# then run power analysis
powerSim(model.coldN)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["manipulationTGI"]
cond_effect <- fixef(model.coldN)["conditionwithin"]
cold_loc_effect <- fixef(model.coldN)["cold_locationprox_caud"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["cold_locationprox_caud"] <- cold_loc_effect
# let's see if this works because it hasn't before
pc.cold <- powerCurve(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition + cold_location, data=getData(model.coldN))
print(dat_model)
# let's see if this works because it hasn't before
pc.cold <- powerCurve(cold.modelN, within='manipulation+condition+cold_location',
breaks=1:5:100))
# can run a power curve to determine the point of trade off between N observations and power
pc.cold <- powerCurve(cold.modelN, within='manipulation+condition+cold_location',
breaks= seq(0, 100, by = 10))
# can run a power curve to determine the point of trade off between N observations and power
pc.cold <- powerCurve(model.coldN, within='manipulation+condition+cold_location',
breaks= seq(0, 100, by = 10))
View(model.coldN)
print(pc.cold)
# First, let's try to add 30 observations per variable combination, which would mean N = 30
model.coldN <- extend(model.cold, within = 'manipulation+condition+cold_location', n=30)
summary(model.coldN)
# check that number of data points per variable does = 30
dat_model <- xtabs(~ manipulation + condition + cold_location, data=getData(model.coldN))
print(dat_model)
# extract fixed effects from the model - take the lowest effect size from the model
tgi_effect <- fixef(model.coldN)["manipulationTGI"]
cond_effect <- fixef(model.coldN)["conditionwithin"]
cold_loc_effect <- fixef(model.coldN)["cold_locationprox_caud"]
# need to estimate minimum desired effect from the change in slope - considering values can range from 0-100, it might be simpler to think of these effect sizes as a proportion of 100 instead
# tgi_effect = -17.05 would perhaps leave an expected effect size of .17
# change the effect size to effect size of interest
fixef(model.coldN)["cold_locationprox_caud"] <- cold_loc_effect
# then run power analysis
pwr.cold <- powerSim(model.coldN)
print(pwr.cold)
# can run a power curve to determine the point of trade off between N observations and power
pc.cold <- powerCurve(model.coldN, within='manipulation+condition+cold_location',
breaks= seq(0, 30, by = 3))
print(pc.cold)
plot(pc.cold) # a good visualisation :)
View(pc.cold)
# can run a power curve to determine the point of trade off between N observations and power
pc.cold <- powerCurve(model.coldN, within='manipulation+condition+cold_location',
breaks= seq(1, 30, by = 3))
print(pc.cold)
plot(pc.cold) # a good visualisation :)
plot(pc.cold) # a good visualisation :)
model.warm <- lmer(rating ~ manipulation + condition + cold_location +
(1|ID) + (1|procedure),
data = df_sum[df_sum$VAS == 'warm' ,])
model.warm <- lmer(rating ~ manipulation + condition + cold_location +
(1|ID) + (1|procedure),
data = df_sum[df_sum$VAS == 'warm' ,])
model.warm <- lmer(rating ~ manipulation + condition + cold_location +
(1|ID),
data = df_sum[df_sum$VAS == 'warm' ,])
summary(model.warm)
# using n050 here as expecting smaller effect sizes
model.warmN <- extend(model.warm, within = 'manipulation+condition+cold_location', n=50)
# extracting effect sizes from the extended model
tgi_effect <- fixef(model.warmN)["manipulationTGI"]
cond_effect <- fixef(model.warmN)["conditionwithin"]
cold_loc_effect <- fixef(model.warmsN)["cold_locationprox_caud"]
cold_loc_effect <- fixef(model.warmN)["cold_locationprox_caud"]
# add smallest effect size - same as cold model
fixef(model.coldN)["cold_locationprox_caud"] <- cold_loc_effect
# then run power analysis
pwr.warm <- powerSim(model.coldN)
print(pwr.warm)
# can run a power curve to determine the point of trade off between N observations and power
pc.warm <- powerCurve(model.warmN, within='manipulation+condition+cold_location',
breaks= seq(1, 50, by = 5))
# then run power analysis
pwr.warm <- powerSim(model.warmN)
# using n050 here as expecting smaller effect sizes
model.warmN <- extend(model.warm, within = 'manipulation+condition+cold_location', n=50)
# extracting effect sizes from the extended model
tgi_effect <- fixef(model.warmN)["manipulationTGI"]
cond_effect <- fixef(model.warmN)["conditionwithin"]
cold_loc_effect <- fixef(model.warmN)["cold_locationprox_caud"]
# add smallest effect size - same as cold model
fixef(model.coldN)["cold_locationprox_caud"] <- cold_loc_effect
# then run power analysis
pwr.warm <- powerSim(model.warmN)
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
library(simr)
# using n050 here as expecting smaller effect sizes
model.warmN <- extend(model.warm, within = 'manipulation+condition+cold_location', n=50)
# extracting effect sizes from the extended model
tgi_effect <- fixef(model.warmN)["manipulationTGI"]
cond_effect <- fixef(model.warmN)["conditionwithin"]
cold_loc_effect <- fixef(model.warmN)["cold_locationprox_caud"]
# add smallest effect size - same as cold model
fixef(model.coldN)["cold_locationprox_caud"] <- cold_loc_effect
# then run power analysis
pwr.warm <- powerSim(model.warmN)
View(model.warm)
View(model.warm)
print(pwr.warm)
# can run a power curve to determine the point of trade off between N observations and power
pc.warm <- powerCurve(model.warmN, within='manipulation+condition+cold_location',
breaks= seq(1, 50, by = 5))
print(pc.warm)
